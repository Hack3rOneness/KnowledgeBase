__author__ = "tccontre - Br3akp0int"

"""
description: 
a script tool to simulate the decryption of iceid malware to its payload encrypted in its .png payload.
this tool is base on several iceid malware variant that using rc4 decryption and same structure in parsing the headers and its decryption key.
"""

import os
import sys
import argparse
import struct as s
import time
import logging
import binascii
import capstone as cs

def custom_logger(name):
    """
    description: function for creating debug logs for debugging error purposes
    :parameter:
    :name: module name that execute this logging function 
    """
    DEBUG_LOGNAME = "iceid_debug.log"
    ### delete old logs
    if os.path.isfile(DEBUG_LOGNAME):
        os.remove(DEBUG_LOGNAME)

    LOG_LEVEL = logging.DEBUG
    CONSOLE_LOG_LEVEL = logging.INFO
    LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)15s - %(funcName)-50s: codeline: %(lineno)4d - %(message)s'
    LOG_FILENAME = os.path.join(os.getcwd(), DEBUG_LOGNAME)


    ### set logging level
    logging.root.setLevel(LOG_LEVEL)
    dbg_format = logging.Formatter(LOG_FORMAT)
    logging.basicConfig(level=LOG_LEVEL, filename= LOG_FILENAME, format=LOG_FORMAT)
    logger = logging.getLogger(name)

    ### define a Handler which writes INFO messages or higher to the sys.stderr
    console = logging.StreamHandler()
    console.setLevel(CONSOLE_LOG_LEVEL)

    ### set a format which is simpler for console use
    formatter = logging.Formatter('%(levelname)-4s %(message)s')

    ### tell the handler to use this format
    console.setFormatter(formatter)

    ### add the handler to the root logger
    logging.getLogger().addHandler(console)

    return logger

### setting up your secretary logger :)
logger = custom_logger("__IceIdPngExtractor__")
logger.debug('[+] MSG: START PAYLOAD EXTRACTION')


class IceIDPNGShellCodeExtractor:

    def __init__(self):
        self.PNG_HEADER = 0x0A1A0A0D474E5089 	 	 	 	 	 	 	
        self.PNG_HEADER_SIZE = 0x8
        self.chunk_data_len_size = 4
        self.chunk_type_size = 4
        self.chunk_crc32_size = 4
        self.dec_key_size = 8
        self.payload_chunk_type = b"IDAT"

        self.idat_chunk_type = 0
        self.idat_chunk_data_len = 0
        self.idat_chunk_type_ofs = 0
        self.idat_chunk_data_len_ofs = 0

        self.extr_shellcode_name = ""

        self.shell_oep = 0
        self.shell_size = 0
        self.shell_hdr = 0
        
        return

    def dumb_header_check(self, f):
        
        ### check png header and insanity minimum file size
        png_header = s.unpack("<Q", f.read(8))[0]
        logger.debug ("[+] MSG: {}".format(hex(png_header)))
        
        if len(f.read()) == 100:
            logger.error ("[~] MSG: input file is too small")
            return False
        elif png_header != self.PNG_HEADER:
            logger.error ("[~] MSG: invalid PNG header")
            return False
        else:
            return True


    def iterate_png_hdr(self, f):
        
        ### initial ptr after png header
        buff_ptr = self.PNG_HEADER_SIZE

        chunk_type_count_limit = 10
        
    
        for i in range(0, chunk_type_count_limit):

            f.seek(buff_ptr,0)
            
            ### parse the chunk data len (big_endian)
            chunk_data_len = int.from_bytes(f.read(self.chunk_data_len_size), byteorder='big', signed=False)
            
            ### parse the 4bytes chunk_type to check the payload chunk_type
            chunk_type = f.read(self.chunk_type_size)
            
            ### if not IDA chunk_type get the data_len value then skip 3 dword header (0xc)
            logger.info("[+] MSG: chunk_type       : {0}  --> file_offset: {1}".format(chunk_type, hex(buff_ptr + self.chunk_data_len_size)))
            logger.info("[+] MSG: chunk_data_length: {0:08x} --> file_offset: {1} (BIG-ENDIAN)".format(chunk_data_len, hex(buff_ptr)))
            logger.debug("[+] MSG: chunk_data      : {}".format(binascii.hexlify(f.read(chunk_data_len))))
            logger.info("[+] MSG: chunk_crc32L     : {0:08x} --> file_offset: {1}".format(int.from_bytes(f.read(self.chunk_crc32_size), byteorder='little', signed=False), hex(buff_ptr + chunk_data_len + self.chunk_type_size + self.chunk_data_len_size)))
            
            ### check if the chunk type is "IDAT"
            if chunk_type != self.payload_chunk_type:
                buff_ptr += chunk_data_len + self.chunk_data_len_size + self.chunk_type_size + self.chunk_crc32_size
            else:
                self.idat_chunk_type = chunk_type
                self.idat_chunk_data_len = chunk_data_len
                self.idat_chunk_type_ofs = buff_ptr + self.chunk_data_len_size
                self.idat_chunk_data_len_ofs = buff_ptr
                logger.info ("[+] MSG: IDAT chunk_type found")
                break          
        return

    def print_table(self, msg, data_list):
        line = []
        logger.info("[+] MSG: {}".format(msg))
        for i in range(0, len(data_list)):
            if i % 16:
                line.append("{0:02x}".format(data_list[i]))
            else:
                logger.info("{}".format(line))
                line = []
                line.append("{0:02x}".format(data_list[i]))
                
        return

    def write_bin(self, file_path, data):
        with open(file_path, "wb") as fw:
            for dec_b in data:
                fw.write(s.pack("B",dec_b))

        return

    def parse_shellcode_header(self):

        with open(self.extr_shellcode_name, 'rb') as f:
            
           
            self.shell_hdr = int.from_bytes(f.read(4), byteorder='little', signed=False)
            logger.info("[+] MSG: DWORD (little) shellcode_header: {0:08x}".format(self.shell_hdr))
            
            logger.info("[+] MSG: DWORD (little) total_encrypted_size: {0:08x}".format(int.from_bytes(f.read(4), byteorder='little', signed=False)))

            self.shell_oep = int.from_bytes(f.read(4), byteorder='little', signed=False)
            logger.info("[+] MSG: DWORD (little) shellcode_entrypoint: {0:08x}".format(self.shell_oep))
            f.seek(0x10)
            self.shell_size = int.from_bytes(f.read(4), byteorder='little', signed=False)
            logger.info("[+] MSG: DWORD (little) shellcode_size: {0:08x}".format(self.shell_size))


        return
    def rc4_decrypt_shellcode(self, dec_key, enc_data_ofs, enc_data_size, f):

        ### 256 KSA table
        s = [0]*256
        j = 0
        out = []
        for i in range(0,256):
            s[i] = i
        self.print_table("RC4 0x100 byte swap table\n---------------------------------------", s)

        for i in range(0,256):
            j = (j + s[i] + (dec_key[i%len(dec_key)])) % 256
            s[i], s[j] = s[j], s[i]
        self.print_table("RC4 KSA table using the dec key\n---------------------------------------",s)

        ##PRGA Phase
        i = j = 0
        f.seek(enc_data_ofs,0)
        enc_data = f.read(enc_data_size)
        for char in enc_data:
            i = ( i + 1 ) % 256
            j = ( j + s[i] ) % 256
            s[i] , s[j] = s[j] , s[i]
            dec_byte = int(char) ^ s[(s[i] + s[j]) % 256]

            out.append(dec_byte)
        
        return out

    def iterate_input(self, png_payload_dir):

        for subdirs, dirs, files in os.walk(png_payload_dir):
            for f in files:
                file_path = os.path.join(subdirs, f)
                if not self.process_payload(file_path):
                    pass
        return

    def save_shellcode(self, shellcode, png_payload_fname):
        ### save the shellcode
        self.extr_shellcode_name = png_payload_fname + "_shellcode.bin"
        self.write_bin(self.extr_shellcode_name, shellcode)
        return

    def disasm_shellcode(self, disasm_size = 0x100):
        with open (self.extr_shellcode_name, 'rb') as fs:
            fs.seek(self.shell_oep)
            shellcode = fs.read(disasm_size)
            addrs = 0x40000 + self.shell_oep
            logger.info("[+] MSG: Disassembling first 0x100 bytes of shellcode starting shellcode oep\n---------------------------------------\n")
            md = cs.Cs(cs.CS_ARCH_X86, cs.CS_MODE_32)
            for inst in md.disasm(shellcode, addrs):
                logger.info("0x%08x:\t%s\t%s" % (inst.address, inst.mnemonic, inst.op_str))
            return

        
                          
    def process_payload(self, png_payload):
        logger.info("\n\n[-] +++++++++++++++++++++++++start extraction+++++++++++++++++++++++++++++ [-]")
        logger.info("[+] MSG: processing -> {}".format(png_payload))
        f = open(png_payload, "rb")
        if not self.dumb_header_check(f):
            logger.debug ("[~] MSG: failed to load input file")
            return False     
        else:
            logger.debug ("[+] MSG: passed dumb header check")

            ### interate to PNG header to look for IDAT chunk type
            self.iterate_png_hdr(f)

            ### check my so called "idat chunk_data valid flag
            logger.info ("[+] MSG: checking the iceid idat data valid byte flag....")
            
            idat_byte_flag_ofs = self.idat_chunk_type_ofs + 8

            f.seek(idat_byte_flag_ofs,0)
            
            idat_flag_byte = int.from_bytes(f.read(1), byteorder='little', signed=False)
            
            if idat_flag_byte == 0:
                logger.error("[~] MSG: zero idat chunk data byte flag...\n\n")
                return False
            else:
                logger.info("[+] MSG: non-zero idat chunk data byte flag ...")

                ### parse the key and encrypted data
                payload_init_key = f.read(self.dec_key_size)
                logger.info("[+] MSG: RC4 decryption key: {} dec_key_size: {}".format(binascii.hexlify(payload_init_key),hex(self.dec_key_size)))

                enc_data_size = self.idat_chunk_data_len - self.chunk_data_len_size - 0x9
                logger.info ("[+] MSG: enc_data_size: {}".format(hex(enc_data_size)))

                ### encrypted data start offset
                enc_data_ofs = f.tell()
                logger.info ("[+] MSG: enc_data_ofs: {}".format(hex(enc_data_ofs)))

                ### decrypt shellcode
                dec_rc4 = self.rc4_decrypt_shellcode(payload_init_key, enc_data_ofs, enc_data_size, f)
                
                ### save it to a file
                self.save_shellcode(dec_rc4, png_payload)
                
                ### shellcode header parser
                self.parse_shellcode_header()
                
                logger.info("[+] MSG: shellcode extracted: {}\n---------------------------------------\n".format(self.extr_shellcode_name))

                self.disasm_shellcode()
        logger.info("[-] +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ [-]\n\n")
        return True


def banner():
    print (r"""
  ___        ___    _ ___ _  _  ___ ___ _        _ _            _     ___     _               _           
 |_ _|__ ___|_ _|__| | _ \ \| |/ __/ __| |_  ___| | |__ ___  __| |___| __|_ _| |_ _ _ __ _ __| |_ ___ _ _ 
  | |/ _/ -_)| |/ _` |  _/ .` | (_ \__ \ ' \/ -_) | / _/ _ \/ _` / -_) _|\ \ /  _| '_/ _` / _|  _/ _ \ '_|
 |___\__\___|___\__,_|_| |_|\_|\___|___/_||_\___|_|_\__\___/\__,_\___|___/_\_\\__|_| \__,_\__|\__\___/_| 
    """)
    return


def main():
    banner()

    """
    description: prepare the argument setup
    """
    parser = argparse.ArgumentParser(description = "IceId PNG Steganography Shellcode Extractor")
    parser.add_argument('-i', '--iceid-png-file',  dest ='pngfile', help = ".png steganography payload of iceid malware either file or multiple png in a dir", required=True)
    args = parser.parse_args()


    ### instantiate the decryptor class
    png_shellcode = IceIDPNGShellCodeExtractor()

    ### start processing
    if os.path.isfile(args.pngfile):
        logger.info("[+] MSG: {} file exist!".format(args.pngfile))
        png_shellcode.process_payload(args.pngfile)
    elif os.path.isdir(args.pngfile):
        logger.info("[+] MSG: {} input file is directory!".format(args.pngfile))
        png_shellcode.iterate_input(args.pngfile)



    
    #if args.pngfile:
    #    print (args.pngfile)
    #if args.keysize:
    #    print (args.keysize)
    

if __name__ == "__main__":
    main()
